package com.bc.dectree.impl;

import com.bc.dectree.DecTreeDoc;
import com.bc.dectree.DecTreeDoc.Property;
import com.bc.dectree.DecTreeDoc.Type;

import java.io.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import static com.bc.dectree.impl.Utilities.getPackageName;
import static com.bc.dectree.impl.Utilities.getSimpleClassName;

public class DecTreeCodeGen {
    private final DecTreeDoc doc;
    private boolean genTimeStamp;

    private DecTreeCodeGen(DecTreeDoc doc, boolean genTimeStamp) {
        this.doc = doc;
        this.genTimeStamp = genTimeStamp;
    }

    public static void writeJava(DecTreeDoc doc, File javaFile, boolean genTimeStamp) throws IOException {
        DecTreeCodeGen gen = new DecTreeCodeGen(doc, genTimeStamp);
        //noinspection ResultOfMethodCallIgnored
        javaFile.getParentFile().mkdirs();
        gen.genCode(new FileWriter(javaFile));
    }

    static void writeJava(DecTreeDoc doc, Writer writer, boolean genTimeStamp) {
        DecTreeCodeGen gen = new DecTreeCodeGen(doc, genTimeStamp);
        gen.genCode(writer);
    }

    private void genCode(Writer writer) {
        List<String> lines = genCode();
        try (PrintWriter w = new PrintWriter(writer)) {
            for (String line : lines) {
                w.print(line);
                w.print("\n");
            }
        }
    }

    private List<String> genCode() {
        String indent = "    ";
        String indent2 = indent + indent;
        String indent3 = indent2 + indent;

        int numInputs = doc.inputs.size();
        int numDerived = doc.derived.size();
        int numOutputs = doc.outputs.size();

        int inputIndex;
        int outputIndex;

        List<String> lines = new ArrayList<>();

        String packageName = getPackageName(doc.name);
        if (!packageName.isEmpty()) {
            lines.add(String.format("package %s;", packageName));
            lines.add("");
        }

        lines.add("import static java.lang.Math.*;");
        lines.add("import com.bc.dectree.DecTreeFunction;");

        lines.add("");
        lines.add(String.format("// Generated by %s", getClass().getName()) + (genTimeStamp ? " on " + new Date() : ""));
        lines.add(String.format("public class %s implements DecTreeFunction {", getSimpleClassName(doc.name)));

        /////////////////////////////////////////////////////////////////////////
        // Generate size accessor methods

        lines.add("");
        lines.add(indent + String.format("public final int getInputSize() { return %s; }", numInputs));
        lines.add(indent + String.format("public final int getOutputSize() { return %s; }", numOutputs));

        /////////////////////////////////////////////////////////////////////////
        // Generate getInputNames() method

        lines.add("");
        lines.add(indent + "public final String[] getInputNames() {");
        lines.add(indent2 + "return new String[] {");
        inputIndex = 0;
        for (String name : doc.inputs.keySet()) {
            lines.add(indent3 + String.format("/*%s*/ \"%s\",", inputIndex, name));
            inputIndex++;
        }
        lines.add(indent2 + "};");
        lines.add(indent + "}");

        /////////////////////////////////////////////////////////////////////////
        // Generate getOutputNames() method

        lines.add("");
        lines.add(indent + "public final String[] getOutputNames() {");
        lines.add(indent2 + "return new String[] {");
        outputIndex = 0;
        for (String name : doc.outputs.keySet()) {
            lines.add(indent3 + String.format("/*%s*/ \"%s\",", outputIndex, name));
            outputIndex++;
        }
        lines.add(indent2 + "};");
        lines.add(indent + "}");

        /////////////////////////////////////////////////////////////////////////
        // Generate apply() method

        lines.add("");
        lines.add(indent + "public final void apply(double[] inputs, double[] outputs) {");
        lines.add(indent2 + String.format("assert inputs.length >= %s;", numInputs));
        lines.add(indent2 + String.format("assert outputs.length >= %s;", numOutputs));

        inputIndex = 0;
        outputIndex = 0;

        if (numInputs > 0) {
            lines.add("");
            for (String name : doc.inputs.keySet()) {
                lines.add(indent2 + String.format("final double %s = inputs[%s];", name, inputIndex));
                inputIndex++;
            }
        }

        if (numDerived > 0) {
            lines.add("");
            for (String name : doc.derived.keySet()) {
                lines.add(indent2 + String.format("final double %s = %s;", name, doc.derived.get(name).expression));
            }
        }

        if (numOutputs > 0) {
            lines.add("");
            for (String name : doc.outputs.keySet()) {
                if (!(doc.inputs.containsKey(name) || doc.derived.containsKey(name))) {
                    lines.add(indent2 + String.format("double %s = 0.0;", name));
                }
            }
        }

        ContextImpl ctx = new ContextImpl();
        lines.add("");
        lines.add(indent2 + String.format("final double %s = 1.0;", ctx.getCurrent()));
        for (DecTreeDoc.Statement statement : doc.rules) {
            lines.addAll(statement.genCode(ctx).stream().map(s -> indent2 + s).collect(Collectors.toList()));
        }

        if (numOutputs > 0) {
            lines.add("");
            for (String name : doc.outputs.keySet()) {
                lines.add(indent2 + String.format("outputs[%s] = %s;", outputIndex, name));
                outputIndex++;
            }
        }

        lines.add(indent + "}");

        /////////////////////////////////////////////////////////////////////////
        // Generate property membership functions

        for (String typeName : doc.types.keySet()) {
            Type type = doc.types.get(typeName);
            for (String propertyName : type.properties.keySet()) {
                Property property = type.properties.get(propertyName);
                lines.add("");
                lines.add(indent + String.format("// %s: %s", type.name, property.code));
                lines.add(indent + String.format("private static double %s_%s(double x) {", type.name, property.name));
                lines.addAll(property.membershipFunction.genCode().stream().map(s -> indent2 + s).collect(Collectors.toList()));
                lines.add(indent + "}");
            }
        }

        lines.add("}");

        return lines;
    }
}