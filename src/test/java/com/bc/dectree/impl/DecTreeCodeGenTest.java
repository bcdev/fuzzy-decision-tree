package com.bc.dectree.impl;

import com.bc.dectree.DecTreeDoc;
import com.bc.dectree.DecTreeParseException;
import org.junit.Assert;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.io.StringWriter;

public class DecTreeCodeGenTest {

    @Test
    public void testFromFile() throws IOException, DecTreeParseException {
        File file = new File("./src/test/resources/dectree_test.yml");
        DecTreeDoc doc = DecTreeDocParser.parseDoc(file);
        File root = new File("./temp/java").getAbsoluteFile();
        File sourceFile = new File(root, String.format("com/bc/dectree/%s.java", "DecTreeCodeGenTest_DecTree"));
        DecTreeCodeGen.writeJava(doc, sourceFile, false);

        StringWriter sw = new StringWriter();
        DecTreeCodeGen.writeJava(doc, sw, false);

        Assert.assertEquals("" +
                "import static java.lang.Math.*;\n" +
                "import com.bc.dectree.DecTreeFunction;\n" +
                "\n" +
                "// Generated by com.bc.dectree.impl.DecTreeCodeGen\n" +
                "public class DecTree3 implements DecTreeFunction {\n" +
                "\n" +
                "    public final int getInputSize() { return 2; }\n" +
                "    public final int getOutputSize() { return 2; }\n" +
                "\n" +
                "    public final String[] getInputNames() {\n" +
                "        return new String[] {\n" +
                "            /*0*/ \"glint\",\n" +
                "            /*1*/ \"radiance\",\n" +
                "        };\n" +
                "    }\n" +
                "\n" +
                "    public final String[] getOutputNames() {\n" +
                "        return new String[] {\n" +
                "            /*0*/ \"cloudy\",\n" +
                "            /*1*/ \"certain\",\n" +
                "            /*2*/ \"radiance_mod\",\n" +
                "        };\n" +
                "    }\n" +
                "\n" +
                "    public final void apply(double[] inputs, double[] outputs) {\n" +
                "        assert inputs.length >= 2;\n" +
                "        assert outputs.length >= 2;\n" +
                "\n" +
                "        final double glint = inputs[0];\n" +
                "        final double radiance = inputs[1];\n" +
                "\n" +
                "        final double radiance_mod = sqrt(1.0 + radiance * radiance);\n" +
                "\n" +
                "        double cloudy = 0.0;\n" +
                "        double certain = 0.0;\n" +
                "\n" +
                "        final double _t0 = 1.0;\n" +
                "        // if radiance is HIGH or radiance is MIDDLE:\n" +
                "        double _t1 = min(_t0, max(Radiance_HIGH(radiance), Radiance_MIDDLE(radiance)));\n" +
                "        //     if glint is LOW:\n" +
                "        double _t2 = min(_t1, Glint_LOW(glint));\n" +
                "        //         cloudy: true\n" +
                "        cloudy = max(cloudy, _t2);\n" +
                "        //         certain: true\n" +
                "        certain = max(certain, _t2);\n" +
                "        //     else:\n" +
                "        _t2 = min(_t1, 1.0 - _t2);\n" +
                "        //         if glint is HIGH:\n" +
                "        double _t3 = min(_t2, Glint_HIGH(glint));\n" +
                "        //             certain: false\n" +
                "        certain = max(certain, 1.0 - _t3);\n" +
                "        // else if radiance_mod is HIGH:\n" +
                "        _t1 = min(_t0, 1.0 - _t1);\n" +
                "        double _t4 = min(1.0 - _t1, Radiance_HIGH(radiance_mod));\n" +
                "        //     cloudy: true\n" +
                "        cloudy = max(cloudy, _t4);\n" +
                "        //     certain: false\n" +
                "        certain = max(certain, 1.0 - _t4);\n" +
                "        // else:\n" +
                "        _t1 = min(_t0, 1.0 - _t1);\n" +
                "        //     certain: true\n" +
                "        certain = max(certain, _t1);\n" +
                "        //     if glint is LOW:\n" +
                "        double _t5 = min(_t1, Glint_LOW(glint));\n" +
                "        //         cloudy: false\n" +
                "        cloudy = max(cloudy, 1.0 - _t5);\n" +
                "\n" +
                "        outputs[0] = cloudy;\n" +
                "        outputs[1] = certain;\n" +
                "    }\n" +
                "\n" +
                "    // boolean: (internal)\n" +
                "    private static double boolean_TRUE(double x) {\n" +
                "        return (x <= 0.0) ? 0.0 : (x <= 1.0) ? x : 1.0;\n" +
                "    }\n" +
                "\n" +
                "    // boolean: (internal)\n" +
                "    private static double boolean_FALSE(double x) {\n" +
                "        return (x <= 0.0) ? 1.0 : (x <= 1.0) ? 1.0 - x : 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // Radiance: inv_ramp(x1=0, x2=50)\n" +
                "    private static double Radiance_LOW(double x) {\n" +
                "        if (x <= 0.0)\n" +
                "            return 1.0;\n" +
                "        if (x <= 50.0)\n" +
                "            return 1.0 - (x - 0.0) / (50.0 - 0.0);\n" +
                "        return 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // Radiance: triangular(x1=30, x2=50, x3=100)\n" +
                "    private static double Radiance_MIDDLE(double x) {\n" +
                "        if (x <= 30.0)\n" +
                "            return 0.0;\n" +
                "        if (x <= 50.0)\n" +
                "            return (x - 30.0) / (50.0 - 30.0);\n" +
                "        if (x <= 100.0)\n" +
                "            return 1.0 - (x - 50.0) / (100.0 - 50.0);\n" +
                "        return 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // Radiance: ramp(x1=50, x2=120)\n" +
                "    private static double Radiance_HIGH(double x) {\n" +
                "        if (x <= 50.0)\n" +
                "            return 0.0;\n" +
                "        if (x <= 120.0)\n" +
                "            return (x - 50.0) / (120.0 - 50.0);\n" +
                "        return 1.0;\n" +
                "    }\n" +
                "\n" +
                "    // Glint: inv_ramp(x1=0.0, x2=0.5)\n" +
                "    private static double Glint_LOW(double x) {\n" +
                "        if (x <= 0.0)\n" +
                "            return 1.0;\n" +
                "        if (x <= 0.5)\n" +
                "            return 1.0 - (x - 0.0) / (0.5 - 0.0);\n" +
                "        return 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // Glint: ramp(x1=0.5, x2=1.0)\n" +
                "    private static double Glint_HIGH(double x) {\n" +
                "        if (x <= 0.5)\n" +
                "            return 0.0;\n" +
                "        if (x <= 1.0)\n" +
                "            return (x - 0.5) / (1.0 - 0.5);\n" +
                "        return 1.0;\n" +
                "    }\n" +
                "}\n", sw.toString());
    }

    @Test
    public void testFromTestData() {
        DecTreeDoc doc = TestData.getDoc("MyDecTree2");
        StringWriter sw = new StringWriter();
        DecTreeCodeGen.writeJava(doc, sw, false);

        Assert.assertEquals("" +
                "import static java.lang.Math.*;\n" +
                "import com.bc.dectree.DecTreeFunction;\n" +
                "\n" +
                "// Generated by com.bc.dectree.impl.DecTreeCodeGen\n" +
                "public class MyDecTree2 implements DecTreeFunction {\n" +
                "\n" +
                "    public final int getInputSize() { return 2; }\n" +
                "    public final int getOutputSize() { return 4; }\n" +
                "\n" +
                "    public final String[] getInputNames() {\n" +
                "        return new String[] {\n" +
                "            /*0*/ \"i1\",\n" +
                "            /*1*/ \"i2\",\n" +
                "        };\n" +
                "    }\n" +
                "\n" +
                "    public final String[] getOutputNames() {\n" +
                "        return new String[] {\n" +
                "            /*0*/ \"o1\",\n" +
                "            /*1*/ \"o2\",\n" +
                "            /*2*/ \"o3\",\n" +
                "            /*3*/ \"d1\",\n" +
                "            /*4*/ \"d1\",\n" +
                "        };\n" +
                "    }\n" +
                "\n" +
                "    public final void apply(double[] inputs, double[] outputs) {\n" +
                "        assert inputs.length >= 2;\n" +
                "        assert outputs.length >= 4;\n" +
                "\n" +
                "        final double i1 = inputs[0];\n" +
                "        final double i2 = inputs[1];\n" +
                "\n" +
                "        final double d1 = i1 * i1 + i2;\n" +
                "\n" +
                "        double o1 = 0.0;\n" +
                "        double o2 = 0.0;\n" +
                "        double o3 = 0.0;\n" +
                "\n" +
                "        final double _t0 = 1.0;\n" +
                "        // \n" +
                "        double _t1 = min(_t0, min(T1_MID(i1), boolean_TRUE(i2)));\n" +
                "        // \n" +
                "        o1 = max(o1, _t1);\n" +
                "        // \n" +
                "        _t1 = min(_t0, 1.0 - _t1);\n" +
                "        double _t2 = min(1.0 - _t1, max(D1_GOOD(d1), boolean_FALSE(i2)));\n" +
                "        // \n" +
                "        o2 = max(o2, _t2);\n" +
                "        // \n" +
                "        _t1 = min(_t0, 1.0 - _t1);\n" +
                "        // \n" +
                "        o3 = max(o3, _t1);\n" +
                "\n" +
                "        outputs[0] = o1;\n" +
                "        outputs[1] = o2;\n" +
                "        outputs[2] = o3;\n" +
                "        outputs[3] = d1;\n" +
                "    }\n" +
                "\n" +
                "    // boolean: (internal)\n" +
                "    private static double boolean_TRUE(double x) {\n" +
                "        return (x <= 0.0) ? 0.0 : (x <= 1.0) ? x : 1.0;\n" +
                "    }\n" +
                "\n" +
                "    // boolean: (internal)\n" +
                "    private static double boolean_FALSE(double x) {\n" +
                "        return (x <= 0.0) ? 1.0 : (x <= 1.0) ? 1.0 - x : 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // T1: LOW:...\n" +
                "    private static double T1_LOW(double x) {\n" +
                "        if (x <= -3)\n" +
                "            return 1.0;\n" +
                "        if (x <= 1)\n" +
                "            return 1.0 - (x - -3) / (1 - -3);\n" +
                "        return 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // T1: MID:...\n" +
                "    private static double T1_MID(double x) {\n" +
                "        if (x <= -2)\n" +
                "            return 0.0;\n" +
                "        if (x <= 0)\n" +
                "            return (x - -2) / (0 - -2);\n" +
                "        if (x <= 2)\n" +
                "            return 1.0 - (x - 0) / (2 - 0);\n" +
                "        return 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // T1: HI:...\n" +
                "    private static double T1_HI(double x) {\n" +
                "        if (x <= 1)\n" +
                "            return 0.0;\n" +
                "        if (x <= 3)\n" +
                "            return (x - 1) / (3 - 1);\n" +
                "        return 1.0;\n" +
                "    }\n" +
                "\n" +
                "    // D1: GOOD:...\n" +
                "    private static double D1_GOOD(double x) {\n" +
                "        if (x <= -3)\n" +
                "            return 1.0;\n" +
                "        if (x <= 1)\n" +
                "            return 1.0 - (x - -3) / (1 - -3);\n" +
                "        return 0.0;\n" +
                "    }\n" +
                "\n" +
                "    // D1: BAD: ...\n" +
                "    private static double D1_BAD(double x) {\n" +
                "        if (x <= -1)\n" +
                "            return 0.0;\n" +
                "        if (x <= 3)\n" +
                "            return (x - -1) / (3 - -1);\n" +
                "        return 1.0;\n" +
                "    }\n" +
                "}\n", sw.toString());
    }
}
